<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <title>Minecraft-подобная игра в одном файле</title>
  <style>
    html, body { height: 100%; margin: 0; overflow: hidden; background: #000; }
    canvas { display: block; width: 100%; height: 100%; }
    #hint { position: fixed; left: 10px; bottom: 10px; color: #fff; background: rgba(0,0,0,.5); padding: 6px 10px; border-radius: 6px; font-family: sans-serif; font-size: 13px; }
  </style>
</head>
<body>
  <canvas id="screen"></canvas>
  <div id="hint">W/A/S/D — движение, мышь — поворот, левая кнопка — удалить блок, правая — поставить блок. Клик по экранам включает курсор.</div>

  <script>
    // Настройки
    const canvas = document.getElementById('screen');
    const ctx = canvas.getContext('2d', { alpha: false });
    let SCREEN_W = window.innerWidth;
    let SCREEN_H = window.innerHeight;
    canvas.width = SCREEN_W;
    canvas.height = SCREEN_H;

    // Мир: простая 2D карта (x, z) с блоками; высота y не учитывается (делаем плоский план)
    const MAP_W = 64;
    const MAP_Z = 64;
    const world = new Uint8Array(MAP_W * MAP_Z);
    function IDX(x, z) { return x + z * MAP_W; }

    // Инициализация мира: границы - стены, внутри - случайные блоки
    for (let x = 0; x < MAP_W; x++) {
      for (let z = 0; z < MAP_Z; z++) {
        if (x === 0 || z === 0 || x === MAP_W - 1 || z === MAP_Z - 1) {
          world[IDX(x, z)] = 1;
        } else if (Math.random() < 0.08) {
          world[IDX(x, z)] = 1;
        }
      }
    }

    // Игрок/камерa
    let px = Math.floor(MAP_W / 2) + 0.5;
    let pz = Math.floor(MAP_Z / 2) + 0.5;
    let yaw = Math.PI * 0.4; // направление взгляда

    const FOV = Math.PI / 3; // 60 градусов
    let lastTime = 0;

    // Управление
    const keys = {};
    window.addEventListener('keydown', (e) => { keys[e.key.toLowerCase()] = true; });
    window.addEventListener('keyup',   (e) => { keys[e.key.toLowerCase()] = false; });

    // Поворот мышью (pointer lock)
    canvas.addEventListener('click', () => {
      canvas.requestPointerLock = canvas.requestPointerLock || canvas.mozRequestPointerLock;
      if (canvas.requestPointerLock) canvas.requestPointerLock();
    });

    let mouseDx = 0;
    document.addEventListener('mousemove', (e) => {
      if (document.pointerLockElement === canvas) {
        mouseDx += e.movementX || 0;
      }
    });

    // Контекст: запретить контекстное меню на правую кнопку
    canvas.addEventListener('contextmenu', (e) => e.preventDefault());

    function inBounds(x, z) { return x >= 0 && z >= 0 && x < MAP_W && z < MAP_Z; }

    // Режим редактирования: последняя попадание луча (для добавления/удаления)
    let hitX = 0, hitZ = 0, hitSide = 0;
    let lastRayDirX = 0, lastRayDirZ = 0;

    // Рендеринг лучами
    function render() {
      // Sky / ground
      ctx.fillStyle = '#87CEEB';
      ctx.fillRect(0, 0, SCREEN_W, SCREEN_H / 2);
      ctx.fillStyle = '#6b4e2e';
      ctx.fillRect(0, SCREEN_H / 2, SCREEN_W, SCREEN_H / 2);

      // Узнаем направления камеры
      const dirX = Math.cos(yaw);
      const dirZ = Math.sin(yaw);

      // Пересчитываем плоскость (перпендикуляр к направлению взгляда)
      const planeX = -dirZ * Math.tan(FOV / 2);
      const planeZ = dirX * Math.tan(FOV / 2);

      // Параметры рендера
      for (let x = 0; x < SCREEN_W; x++) {
        const cameraX = 2 * x / SCREEN_W - 1;
        const rayDirX = dirX + planeX * cameraX;
        const rayDirZ = dirZ + planeZ * cameraX;

        // DDA по сетке (x,z)
        let mapX = Math.floor(px);
        let mapZ = Math.floor(pz);

        const deltaDistX = Math.abs(1 / (rayDirX || 1e-6));
        const deltaDistZ = Math.abs(1 / (rayDirZ || 1e-6));

        let stepX, stepZ;
        let sideDistX, sideDistZ;

        if (rayDirX < 0) { stepX = -1; sideDistX = (px - mapX) * deltaDistX; }
        else { stepX = 1; sideDistX = (mapX + 1.0 - px) * deltaDistX; }

        if (rayDirZ < 0) { stepZ = -1; sideDistZ = (pz - mapZ) * deltaDistZ; }
        else { stepZ = 1; sideDistZ = (mapZ + 1.0 - pz) * deltaDistZ; }

        let hit = false;
        let side = 0; // 0 = X-стена, 1 = Z-стена
        let mx = mapX, mz = mapZ;

        // Ограничимся на случай выхода за рамки
        while (!hit) {
          if (sideDistX < sideDistZ) {
            sideDistX += deltaDistX;
            mx += stepX;
            side = 0;
          } else {
            sideDistZ += deltaDistZ;
            mz += stepZ;
            side = 1;
          }
          if (!inBounds(mx, mz)) { // за пределами мира — считать как стена
            hit = true;
            mx = Math.max(0, Math.min(MAP_W - 1, mx));
            mz = Math.max(0, Math.min(MAP_Z - 1, mz));
            break;
          }
          if (world[IDX(mx, mz)] > 0) {
            hit = true;
          }
        }

        // Расстояние до стены
        let perpWallDist;
        if (hit) {
          if (side === 0) perpWallDist = (mx - px + (1 - stepX) / 2) / (rayDirX);
          else            perpWallDist = (mz - pz + (1 - stepZ) / 2) / (rayDirZ);
        } else {
          perpWallDist = 1000;
        }

        // Запоминаем для действий мышью
        hitX = mx; hitZ = mz; hitSide = side;
        lastRayDirX = rayDirX; lastRayDirZ = rayDirZ;

        // Нормализация и отрисовка стены
        const lineHeight = Math.max(1, Math.floor(SCREEN_H / (perpWallDist || 0.0001)));
        const drawStart = Math.max(0, Math.floor((SCREEN_H / 2) - lineHeight / 2));
        const drawEnd = Math.min(SCREEN_H - 1, Math.floor((SCREEN_H / 2) + lineHeight / 2));

        // Цвет блока (мог бы зависеть от типа блока; здесь просто один цвет с затенением)
        let r = 210, g = 180, b = 140;
        const shade = (hitSide === 0) ? 0.85 : 0.65;
        r = Math.floor(r * shade);
        g = Math.floor(g * shade);
        b = Math.floor(b * shade);
        ctx.fillStyle = `rgb(${r},${g},${b})`;
        ctx.fillRect(x, drawStart, 1, Math.max(1, drawEnd - drawStart));

        // Сохраняем для редактора
        // hitX/hitZ/hitSide уже обновляются в каждой итерации
      }
      // Обновление хвоста: применяем небольшую задержку перед следующей сценой
    }

    // Обновление игрока
    function update(dt) {
      // Управление движением
      const moveSpeed = 6.0; // единицы в секунду
      const rotationSpeed = 2.4; // радианы в секунду

      // Широкий доступ к движению вперед/назад
      // Направление взгляда: dirX, dirZ
      const dx = Math.cos(yaw);
      const dz = Math.sin(yaw);
      const rightX = Math.cos(yaw + Math.PI / 2);
      const rightZ = Math.sin(yaw + Math.PI / 2);

      // Вперёд/назад
      if (keys['w'] || keys['ц'] || keys['arrowup']) {
        const nx = px + dx * moveSpeed * dt;
        const nz = pz + dz * moveSpeed * dt;
        if (world[IDX(Math.floor(nx), Math.floor(pz))] === 0) px = nx;
        if (world[IDX(Math.floor(px), Math.floor(nz))] === 0) pz = nz;
      }
      if (keys['s'] || keys['ц'] || keys['arrowdown']) {
        const nx = px - dx * moveSpeed * dt;
        const nz = pz - dz * moveSpeed * dt;
        if (world[IDX(Math.floor(nx), Math.floor(pz))] === 0) px = nx;
        if (world[IDX(Math.floor(px), Math.floor(nz))] === 0) pz = nz;
      }

      // Стрafe/поворот
      if (keys['a'] || keys['arrowleft']) {
        yaw -= rotationSpeed * dt;
      }
      if (keys['d'] || keys['arrowright']) {
        yaw += rotationSpeed * dt;
      }

      // Обработка мыши для плавного поворота (если есть движение мыши)
      if (Math.abs(mouseDx) > 0.0001) {
        yaw += mouseDx * 0.004;
        mouseDx = 0;
      }

      // Редактирование блоков мышью
      // левая кнопка удалит блок под попаданием current hit
      // правая кнопка поставит блок рядом с попаданием
    }

    // Обработчик кликов для редактирования мира
    window.addEventListener('mousedown', (e) => {
      // на месте клика выполняем редактирование
      const gx = hitX, gz = hitZ;
      if (e.button === 0) { // левая кнопка — удалить
        if (inBounds(gx, gz) && world[IDX(gx, gz)] > 0) {
          world[IDX(gx, gz)] = 0;
        }
      } else if (e.button === 2) { // правая кнопка — поставить
        // определить соседний блок по направлению взгляда
        let placeX = gx, placeZ = gz;
        if (hitSide === 0) {
          placeX = gx + (lastRayDirX > 0 ? 1 : -1);
        } else {
          placeZ = gz + (lastRayDirZ > 0 ? 1 : -1);
        }
        if (inBounds(placeX, placeZ) && world[IDX(placeX, placeZ)] === 0) {
          world[IDX(placeX, placeZ)] = 1;
        }
      }
    });

    // Главный цикл
    function loop(ts) {
      if (!lastTime) lastTime = ts;
      const dt = Math.min(0.05, (ts - lastTime) / 1000);
      lastTime = ts;

      update(dt);
      render();

      requestAnimationFrame(loop);
    }

    // Адаптация под изменение размера окна
    window.addEventListener('resize', () => {
      SCREEN_W = window.innerWidth;
      SCREEN_H = window.innerHeight;
      canvas.width = SCREEN_W;
      canvas.height = SCREEN_H;
    });

    // Старт
    // Галочка: темп, чтобы в браузере не зависало
    requestAnimationFrame(loop);
  </script>
</body>
</html>
